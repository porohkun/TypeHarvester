namespace TypeHarvester.Generators;

using System.Text;
using Abstractions;
using Configs;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

/// <summary>
/// Генератор, создающий вспомогательный класс для получения всех типов,
/// помеченных заданными атрибутами. Позволяет обходить использование рефлексии
/// и проблемы, связанные с незагруженными сборками.
/// </summary>
[Generator]
internal partial class CollectTypesWithAttributesGenerator :
    BaseIncrementalGenerator<CollectTypesWithAttributesGenerator, CollectTypesWithAttributesConfig, (string Type, string[] Attributes)?>
{
    private const string GeneratedFileName = "TypesByAttributes.g.cs";

    /// <inheritdoc />
    protected override bool IsCollectToCache(CollectTypesWithAttributesConfig config) => config.CollectToCache;

    /// <inheritdoc />
    protected override string CacheSyntaxEntry((string Type, string[] Attributes)? entry) => entry is not null
        ? $"{entry.Value.Type}|{string.Join("|", entry.Value.Attributes)}"
        : string.Empty;

    /// <inheritdoc />
    protected override (string Type, string[] Attributes)? SyntaxEntryFromCache(string cache)
    {
        var split = cache.Split('|');
        return split switch
        {
            { Length: >= 2 } => (Type: split[0], Attributes: split.Skip(1).ToArray()),
            _ => null
        };
    }

    /// <inheritdoc />
    protected override bool NodeFilter(SyntaxNode node, CancellationToken cancellationToken) =>
        node is ClassDeclarationSyntax cds && cds.AttributeLists.Any(list => list.Attributes.Any());

    /// <inheritdoc />
    protected override (string Type, string[] Attributes)? ContextTransform(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        if (context.SemanticModel.GetDeclaredSymbol((ClassDeclarationSyntax)context.Node) is not INamedTypeSymbol symbol)
            return null;

        return (Type: symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).WithoutGlobal(),
            Attributes: symbol.GetAttributes()
                .Select(a => a.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).WithoutGlobal())
                .OfType<string>()
                .ToArray());
    }

    /// <inheritdoc />
    protected override bool NeedsFiltering(CollectTypesWithAttributesConfig config) => config.Attributes.Any(a => !string.IsNullOrWhiteSpace(a));

    /// <inheritdoc />
    protected override bool FilterByConfig((string Type, string[] Attributes)? item, CollectTypesWithAttributesConfig config)
    {
        if (item is not { Attributes: { Length: > 0 } attrs })
            return false;

        var allowed = new HashSet<string>(config.Attributes);
        return attrs.Any(allowed.Contains);
    }

    /// <inheritdoc />
    protected override void GenerateFiles(
        SourceProductionContext spc,
        CollectTypesWithAttributesConfig config,
        (string Type, string[] Attributes)?[] values)
    {
        var allowedAttributes = config.Attributes.Where(a => !string.IsNullOrWhiteSpace(a)).ToArray();
        var types = values
            .Where(x => x is { Attributes: not null } && !string.IsNullOrEmpty(x.Value.Type))
            .SelectMany(x => x!.Value.Attributes
                .Where(attr => !string.IsNullOrEmpty(attr) && allowedAttributes.Contains(attr))
                .Select(attr => (x.Value.Type, Attribute: attr)))
            .ToLookup(x => x.Attribute, x => x.Type)
            .ToDictionary(
                g => g.Key,
                g => g.ToArray());

        var generated = Generate(
                new Dictionary<string, object>
                {
                   { "Types", types },
                   { "Namespace", config.NamespaceForGenerations! },
                   { "Partial", config.Partial }
                });

        spc.AddSource(GeneratedFileName, SourceText.From(generated, new UTF8Encoding(true)));
    }

    /// <inheritdoc />
    protected override void ClearFiles(SourceProductionContext spc) =>
        spc.AddSource(
            GeneratedFileName,
            SourceText.From(
                @"//------------------------------------------------------------------------------
// <auto-generated>
//     Очищен вследствие отключенного или пустого конфига.
// </auto-generated>
//------------------------------------------------------------------------------
internal static class TypesByAttributes
{
    internal static IEnumerable<Type> Get<TAttribute>()
    {
        yield break;
    }
}",
                new UTF8Encoding(true)));
}