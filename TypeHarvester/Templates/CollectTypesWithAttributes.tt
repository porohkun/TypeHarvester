<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cs" #>
<#@ parameter name="Version" type="string" #>
<#@ parameter name="Types" type="System.Collections.Generic.Dictionary<string, string[]>" #>
<#@ parameter name="Namespace" type="string" #>
<#@ parameter name="Partial" type="bool" #>
<# var partialLex = Partial ? "partial " : string.Empty; #>
//------------------------------------------------------------------------------
// <auto-generated>
//     Этот код был создан автоматически с помощью TypeHarvester v.<#= Version #>.
//     Внесение изменений в этот файл может привести к неправильной работе
//     и будет потеряно при повторной генерации кода.
// </auto-generated>
//------------------------------------------------------------------------------

<# if (Namespace != null) {#>
namespace <#= Namespace #>;
<# } #>

using System;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Предоставляет методы для получения всех типов, помеченных выбранными атрибутами
/// </summary>
internal static <#= partialLex #>class TypesByAttributes
{
    private const string ExceptionText = @"Атрибут {0} не был зарегистрирован как допустимый.
Чтобы исправить это создайте файл codegen.config.json в корне проекта и запишите туда следующее:
{{
  ""Attributes"": [
    ""{0}""
  ]
}}
А так же подключите этот файл в проект следующим образом:
<ItemGroup>
  <PackageReference Include=""TypeHarvester"" Version=""latest"">
    <PrivateAssets>all</PrivateAssets>
    <IncludeAssets> analyzers;</IncludeAssets>
  </PackageReference>
  <AdditionalFiles Include=""codegen.config.json"" />
</ItemGroup>";

    private static readonly Dictionary<Type,Type[]> TypesCache = new Dictionary<Type,Type[]>
    {
<# foreach (var pair in Types) { #>
        { typeof(<#= pair.Key #>), new Type[]
            {
<# foreach (var type in pair.Value) { #>
                typeof(<#= type #>),
<# } #>
            }
        },
<# } #>
    };

    /// <summary>
    /// Возвращает все типы, помеченные указанным атрибутом.
    /// </summary>
    /// <typeparam name="TAttribute">Тип атрибута</typeparam>
    internal static <#= partialLex #>IEnumerable<Type> Get<TAttribute>()
    {
        foreach (var type in GetInternal(typeof(TAttribute)))
            yield return type;
    }
    
    /// <summary>
    /// Возвращает все типы, помеченные указанными атрибутами.
    /// </summary>
    /// <typeparam name="TAttribute1">Тип атрибута 1</typeparam>
    /// <typeparam name="TAttribute2">Тип атрибута 2</typeparam>
    internal static <#= partialLex #>IEnumerable<Type> Get<TAttribute1, TAttribute2>()
    {
        foreach (var type in Get(typeof(TAttribute1), typeof(TAttribute2)))
            yield return type;
    }
    
    /// <summary>
    /// Возвращает все типы, помеченные указанными атрибутами.
    /// </summary>
    /// <typeparam name="TAttribute1">Тип атрибута 1</typeparam>
    /// <typeparam name="TAttribute2">Тип атрибута 2</typeparam>
    /// <typeparam name="TAttribute3">Тип атрибута 3</typeparam>
    internal static <#= partialLex #>IEnumerable<Type> Get<TAttribute1, TAttribute2, TAttribute3>()
    {
        foreach (var type in Get(typeof(TAttribute1), typeof(TAttribute2), typeof(TAttribute3)))
            yield return type;
    }
    
    /// <summary>
    /// Возвращает все типы, помеченные указанными атрибутами.
    /// </summary>
    /// <param name="attributeTypes">Типы атрибутов</param>
    internal static <#= partialLex #>IEnumerable<Type> Get(params Type[] attributeTypes)
    {
        foreach (var type in attributeTypes.SelectMany(t=> GetInternal(t)).Distinct())
            yield return type;
    }

    private static IEnumerable<Type> GetInternal(Type attributeType)
    {
        foreach (var type in TypesCache.TryGetValue(attributeType, out var types)
                     ? types
                     : throw new Exception(string.Format(ExceptionText, attributeType.FullName)))
            yield return type;
    }
}